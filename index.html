<!DOCTYPE html>
<html lang="zh-TW">
<head>
<meta charset="UTF-8">
<title>è·‘æ­¥æ•™ç·´ç¯€æ‹å™¨ - å°ˆæ¥­ç‰ˆ</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<style>
:root { --primary: #ff6a00; --bg: #f4f7f9; --card: #ffffff; }
body { font-family: system-ui, -apple-system, sans-serif; background: var(--bg); color: #333; padding: 15px; margin: 0; }
.card { background: var(--card); border-radius: 15px; padding: 15px; box-shadow: 0 4px 12px rgba(0,0,0,0.08); margin-bottom: 15px; }
h2 { color: var(--primary); margin-top: 0; text-align: center; }
table { width: 100%; border-collapse: collapse; margin-top: 10px; font-size: 14px; }
th, td { border-bottom: 1px solid #eee; padding: 10px 5px; text-align: center; }
input { width: 55px; padding: 6px; border: 1px solid #ddd; border-radius: 6px; text-align: center; font-size: 16px; }
.display-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin: 15px 0; }
.stat-box { background: #fff8f4; padding: 10px; border-radius: 10px; text-align: center; border: 1px solid #ffe0cc; }
.stat-val { font-size: 24px; font-weight: bold; color: var(--primary); display: block; font-family: monospace; }
.stat-label { font-size: 12px; color: #666; }
.btn-group { display: flex; gap: 10px; justify-content: center; }
button { flex: 1; padding: 12px; border: none; border-radius: 10px; font-weight: bold; cursor: pointer; font-size: 16px; }
.btn-start { background: var(--primary); color: white; }
.btn-stop { background: #666; color: white; }
.btn-finish { background: #2ecc71; color: white; display: none; }
#status { text-align: center; font-weight: bold; padding: 10px; margin-top: 10px; border-radius: 8px; background: #eee; }
.overtime { background: #fff0f0 !important; border: 2px solid #e74c3c !important; animation: pulse 2s infinite; }
@keyframes pulse { 0% { opacity: 1; } 50% { opacity: 0.7; } 100% { opacity: 1; } }
.history-item { font-size: 13px; display: flex; justify-content: space-between; align-items: center; border-bottom: 1px solid #eee; padding: 8px 0; }
</style>
</head>
<body>

<div class="card">
  <h2>ğŸƒ è·‘æ­¥è¨“ç·´ç¯€æ‹å™¨</h2>
  <table id="planTable">
    <thead><tr><th>éšæ®µ</th><th>BPM</th><th>ç§’æ•¸</th></tr></thead>
    <tbody id="planBody">
      </tbody>
  </table>
  <div style="margin-top: 10px; text-align: center;">
    <label>å¾ªç’°çµ„æ•¸ï¼š</label>
    <input id="loopCount" type="number" value="5">
  </div>
</div>

<div class="card" id="displayCard">
  <div class="display-grid">
    <div class="stat-box"><span class="stat-label">å·²ç”¨æ™‚é–“</span><span id="elapsed" class="stat-val">00:00</span></div>
    <div class="stat-box"><span class="stat-label">ç´¯ç©è·é›¢ (km)</span><span id="distance" class="stat-val">0.00</span></div>
    <div class="stat-box"><span class="stat-label">ç›®å‰é…é€Ÿ</span><span id="pace" class="stat-val">--:--</span></div>
    <div class="stat-box"><span class="stat-label">æœ¬æ®µå‰©é¤˜</span><span id="countdown" class="stat-val">--</span></div>
  </div>
  <div id="status">æº–å‚™å°±ç·’</div>
  <p id="gpsInfo" style="font-size: 10px; color: #999; text-align: center; margin: 5px 0 0 0;">GPS æœªå•Ÿå‹•</p>
</div>

<div class="btn-group">
  <button id="mainBtn" onclick="toggleStart()" class="btn-start">é–‹å§‹è¨“ç·´</button>
  <button id="finishBtn" onclick="stopRun(true)" class="btn-finish">çµæŸä¸¦å„²å­˜</button>
</div>

<div class="card" style="margin-top: 20px;">
  <strong>æ­·å²ç´€éŒ„ (TCX åŒ¯å‡º)</strong>
  <div id="historyList"></div>
</div>

<script>
/* ---------------- é è¨­è¨­å®šèˆ‡è¨˜æ†¶åŠŸèƒ½ ---------------- */
const DEFAULT_PLAN = [
  { name: 'ç†±èº«', bpm: 180, sec: 180 },
  { name: 'ç‡ƒè„‚', bpm: 190, sec: 30 },
  { name: 'é–“æ­‡', bpm: 210, sec: 40 },
  { name: 'è¶…æ…¢è·‘', bpm: 180, sec: 110 },
  { name: 'èˆ’ç·©', bpm: 180, sec: 180 }
];

let config = JSON.parse(localStorage.getItem('run_config')) || { plan: DEFAULT_PLAN, loops: 5 };

// åˆå§‹åŒ–è¡¨æ ¼
function initTable() {
  const body = document.getElementById('planBody');
  body.innerHTML = config.plan.map((s, i) => `
    <tr>
      <td>${s.name}</td>
      <td><input type="number" value="${s.bpm}" onchange="updateConfig(${i}, 'bpm', this.value)"></td>
      <td><input type="number" value="${s.sec}" onchange="updateConfig(${i}, 'sec', this.value)"></td>
    </tr>
  `).join('');
  document.getElementById('loopCount').value = config.loops;
}

function updateConfig(idx, key, val) {
  config.plan[idx][key] = parseInt(val);
  localStorage.setItem('run_config', JSON.stringify(config));
}

document.getElementById('loopCount').onchange = (e) => {
  config.loops = parseInt(e.target.value);
  localStorage.setItem('run_config', JSON.stringify(config));
};

/* ---------------- æ ¸å¿ƒè®Šæ•¸ ---------------- */
let isRunning = false;
let isOvertime = false;
let elapsedSec = 0;
let totalDist = 0;
let watchId = null;
let timerId = null;
let trackPoints = []; // ç”¨æ–¼ç”Ÿæˆ TCX çš„è»Œè·¡é»
let audioCtx = null;
let lastPos = null;

/* ---------------- GPS & è·é›¢ ---------------- */
function haversine(lat1, lon1, lat2, lon2) {
  const R = 6371000;
  const dLat = (lat2 - lat1) * Math.PI / 180;
  const dLon = (lon2 - lon1) * Math.PI / 180;
  const a = Math.sin(dLat/2)**2 + Math.cos(lat1*Math.PI/180)*Math.cos(lat2*Math.PI/180)*Math.sin(dLon/2)**2;
  return R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
}

function startGPS() {
  if (!navigator.geolocation) return;
  watchId = navigator.geolocation.watchPosition(pos => {
    const { latitude, longitude, accuracy, timestamp } = pos.coords;
    document.getElementById('gpsInfo').innerText = `ç²¾æº–åº¦: Â±${Math.round(accuracy)}m`;
    
    // éæ¿¾æ©Ÿåˆ¶ï¼šç²¾åº¦éœ€å°æ–¼ 35 å…¬å°ºæ‰è¨˜éŒ„
    if (accuracy < 35) {
      if (lastPos) {
        const d = haversine(lastPos.lat, lastPos.lon, latitude, longitude);
        // åªæœ‰ä½ç§»è¶…é 2 å…¬å°ºä¸”é…é€Ÿåˆç†çš„é»æ‰è¨ˆç®—ï¼Œé¿å…åŸåœ°è·³å‹•
        if (d > 2 && d < 25) { 
          totalDist += d;
          document.getElementById('distance').innerText = (totalDist / 1000).toFixed(2);
          updatePace();
        }
      }
      lastPos = { lat: latitude, lon: longitude };
      trackPoints.push({ lat: latitude, lon: longitude, time: new Date().toISOString(), dist: totalDist });
    }
  }, err => console.error(err), { enableHighAccuracy: true, maximumAge: 0 });
}

/* ---------------- ç¯€æ‹å™¨ & æµç¨‹ ---------------- */
function playBeep() {
  if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  const osc = audioCtx.createOscillator();
  const gain = audioCtx.createGain();
  osc.connect(gain); gain.connect(audioCtx.destination);
  osc.frequency.value = 1000; gain.gain.value = 0.5;
  osc.start(); gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);
  osc.stop(audioCtx.currentTime + 0.12);
}

async function runSession() {
  isRunning = true;
  elapsedSec = 0;
  totalDist = 0;
  trackPoints = [];
  lastPos = null;
  startGPS();
  
  // å•Ÿå‹•ç¸½è¨ˆæ™‚å™¨
  timerId = setInterval(() => {
    elapsedSec++;
    document.getElementById('elapsed').innerText = formatTime(elapsedSec);
  }, 1000);

  const plan = config.plan;
  const loops = config.loops;

  // 1. ç†±èº«
  await performStage(plan[0], "ğŸƒ ç†±èº«ä¸­");

  // 2. å¾ªç’°çµ„
  for (let i = 1; i <= loops; i++) {
    if (!isRunning) return;
    for (let j = 1; j <= 3; j++) { // é–“æ­‡ä¸‰éšæ®µ
      if (!isRunning) return;
      await performStage(plan[j], `ç¬¬ ${i}/${loops} çµ„: ${plan[j].name}`);
    }
  }

  // 3. èˆ’ç·©
  await performStage(plan[4], "ğŸš¶ èˆ’ç·©ä¸­");

  // 4. çµæŸå¾Œè‡ªå‹•é€²å…¥ç„¡é™å»¶é•·æ¨¡å¼
  enterOvertime(plan[4]);
}

async function performStage(stage, label) {
  if (!isRunning) return;
  document.getElementById('status').innerText = label;
  let remaining = stage.sec;
  const beatInterval = 60000 / stage.bpm;

  return new Promise(resolve => {
    let stageTimer = setInterval(() => {
      if (!isRunning) { clearInterval(stageTimer); resolve(); return; }
      remaining--;
      document.getElementById('countdown').innerText = remaining;
      if (remaining <= 0) { clearInterval(stageTimer); resolve(); }
    }, 1000);

    let beatTimer = setInterval(() => {
      if (!isRunning || remaining <= 0) { clearInterval(beatTimer); return; }
      playBeep();
    }, beatInterval);
  });
}

function enterOvertime(lastStage) {
  isOvertime = true;
  document.getElementById('status').innerText = "âœ¨ è¨“ç·´å·²é”æ¨™ (åŠ å¼·è¨ˆæ™‚ä¸­)";
  document.getElementById('displayCard').classList.add('overtime');
  document.getElementById('finishBtn').style.display = 'block';
  document.getElementById('mainBtn').innerText = "åœæ­¢ä¸¦æ”¾æ£„";
  document.getElementById('countdown').innerText = "âˆ";

  // æŒçºŒç™¼å‡ºæœ€å¾Œä¸€æ®µçš„ç¯€æ‹
  const beatInterval = 60000 / lastStage.bpm;
  const overtimeBeat = setInterval(() => {
    if (!isRunning || !isOvertime) { clearInterval(overtimeBeat); return; }
    playBeep();
  }, beatInterval);
}

/* ---------------- åŠŸèƒ½è¼”åŠ© ---------------- */
function toggleStart() {
  if (!isRunning) {
    document.getElementById('mainBtn').innerText = "å¼·åˆ¶åœæ­¢";
    document.getElementById('mainBtn').className = "btn-stop";
    runSession();
  } else {
    if (confirm("è¨“ç·´å°šæœªçµæŸï¼Œç¢ºå®šè¦åœæ­¢å—ï¼Ÿ(ä¸æœƒå„²å­˜)")) {
      stopRun(false);
    }
  }
}

function stopRun(shouldSave) {
  if (shouldSave && trackPoints.length > 0) {
    saveToHistory();
  }
  isRunning = false;
  isOvertime = false;
  clearInterval(timerId);
  if (watchId) navigator.geolocation.clearWatch(watchId);
  
  document.getElementById('mainBtn').innerText = "é–‹å§‹è¨“ç·´";
  document.getElementById('mainBtn').className = "btn-start";
  document.getElementById('finishBtn').style.display = 'none';
  document.getElementById('displayCard').classList.remove('overtime');
  document.getElementById('status').innerText = shouldSave ? "ç´€éŒ„å·²å„²å­˜" : "å·²é‡è¨­";
}

function formatTime(s) {
  return Math.floor(s/60).toString().padStart(2,'0') + ":" + (s%60).toString().padStart(2,'0');
}

function updatePace() {
  if (totalDist < 10) return;
  const paceSec = elapsedSec / (totalDist / 1000);
  document.getElementById('pace').innerText = formatTime(Math.floor(paceSec));
}

/* ---------------- TCX åŒ¯å‡ºé‚è¼¯ ---------------- */
function saveToHistory() {
  const records = JSON.parse(localStorage.getItem('run_history') || "[]");
  const newRec = {
    id: Date.now(),
    date: new Date().toLocaleString(),
    dist: (totalDist / 1000).toFixed(2),
    time: formatTime(elapsedSec),
    points: trackPoints
  };
  records.unshift(newRec);
  localStorage.setItem('run_history', JSON.stringify(records));
  renderHistory();
}

function exportTCX(id) {
  const records = JSON.parse(localStorage.getItem('run_history'));
  const data = records.find(r => r.id === id);
  if (!data) return;

  let tcx = `<?xml version="1.0" encoding="UTF-8"?>
<TrainingCenterDatabase xmlns="http://www.garmin.com/xmlschemas/TrainingCenterDatabase/v2">
  <Activities>
    <Activity Sport="Running">
      <Id>${new Date(data.id).toISOString()}</Id>
      <Lap StartTime="${new Date(data.id).toISOString()}">
        <TotalTimeSeconds>${elapsedSec}</TotalTimeSeconds>
        <DistanceMeters>${data.dist * 1000}</DistanceMeters>
        <Track>`;
  
  data.points.forEach(p => {
    tcx += `
          <Trackpoint>
            <Time>${p.time}</Time>
            <Position>
              <LatitudeDegrees>${p.lat}</LatitudeDegrees>
              <LongitudeDegrees>${p.lon}</LongitudeDegrees>
            </Position>
            <DistanceMeters>${p.dist.toFixed(1)}</DistanceMeters>
          </Trackpoint>`;
  });

  tcx += `</Track>
      </Lap>
    </Activity>
  </Activities>
</TrainingCenterDatabase>`;

  const blob = new Blob([tcx], { type: 'application/tcx+xml' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url; a.download = `Run_${data.id}.tcx`;
  a.click();
}

function renderHistory() {
  const records = JSON.parse(localStorage.getItem('run_history') || "[]");
  document.getElementById('historyList').innerHTML = records.map(r => `
    <div class="history-item">
      <span>${r.date}<br><small>${r.dist}km / ${r.time}</small></span>
      <button onclick="exportTCX(${r.id})" style="padding:4px 8px; flex:none; font-size:12px;">åŒ¯å‡º TCX</button>
    </div>
  `).join('');
}

window.onload = () => {
  initTable();
  renderHistory();
};
</script>
</body>
</html>
